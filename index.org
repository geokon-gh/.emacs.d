#+TITLE: Emacs configuration
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://geokon-gh.github.io/static/worg.css" />
#+options: num:nil
# This will export a README.org file for Github, so that people that land in my repo know where to find the relevant webpage
#+BEGIN_SRC org :tangle README.org :exports none
  see description [[http://geokon-gh.github.io/.emacs.d/index.html][here]]
#+END_SRC

* Intro
Starting from knowing nothing I documented writing my first Emacs configuration file. It should serve as a gentle guide to writing your own and understanding other people's configurations. I've found that the most important aspect in writing and reading configurations is understanding how emacs helps you figure out what you don't understand. Knowing elisp won't be necessary!
* General Settings
** Package managment
To extend Emacs we will want to be able to add extenal packages. Emacs comes with a package manager called ~package~. To get a more detailed description type ~C-h P package RET~. Using the ~require~ function we can load this feature.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'package)
  (package-initialize)
#+END_SRC
# TODO: figure out why a lot of people have
# (setq package-enable-at-startup nil)
# at the top of their init file and then a 
# (package-initialize) 
# at the end..
To see more specifically what the ~require~ function does type ~C-h f require RET~\\

The second line runs some function that's inside of ~package~ which will initialize the package feature - you can also look it up using ~C-h f~. You'll find that virtually every function will have some associted documentation

Note the use of a leading quote before the word ~package~; This tells emacs that the word ~package~ is a symbol. If you ommit the quote then emacs will try to evaluate ~package~ as a function and give you an error.

Next we tell the package manager where to look for packages. The standard here is [[https://melpa.org][~MELPA~]], and we just need to add it to the list ~package-archives~\\
To look up a variable, use ~C-h v [variable] RET~
So type ~C-h v package-archives RET~ to see what it's for
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/"))
#+END_SRC
This ~C-h [something] [something]~ pattern repeats for a lot of features. To see the complete list just enter ~C-h C-h~. These key-bindings will be your way of exploring configurations you find online.
** Indentation - Change the default indentation from 2 spaces to 4
Indentation is generally govered by two variables\\ 
~default-tab-width~ - this is the variable for any text document when you normally type in a TAB\\
~c-basic-offset~ - when working with source code the indentation is done automatically and based on this offset value  (a lot of modes derive from ~c-mode~, hence the name) \\ 
More info: https://kb.iu.edu/d/abde \\ 
Our first attempt at changing this value:
#+BEGIN_SRC emacs-lisp
  (set 'c-basic-offset 4)
#+END_SRC
Note again the leading quote that prevents ~c-basic-offset~ from being evaluated as a function. Since we are almost always directly assigning to a symbol, emacs gives us the function ~setq~ as a quick short hand that will automatically quote the first argument
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq c-basic-offset 4)
#+END_SRC
This shorthand is used so extensively that'll you'll rarely see the ~set~ method.
** Line wrap
Next we need to enable line-wrap in org mode. By default, as you keep typing the page scrolls to the right. So a whole paragraph will appear as one line making it difficult to navigate
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'org-mode-hook (lambda () (setq truncate-lines nil)))
#+END_SRC
again, don't hesitate to look up all the variables and function
** Theme
This is the only decent light theme I could find. It colors a bit more stuff than the default - like code blocks in org-mode
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'moe-theme)
  (moe-light)
#+END_SRC
* Orgmode
** Some adjustments to org-mode
see [[http://howardism.org/Technical/Emacs/literate-programming-tutorial.html][here]] for reference \\
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq org-confirm-babel-evaluate nil ;; don't prompt for confirmation about executing a block
        org-src-tab-acts-natively t
        org-use-sub-superscripts '{}
        org-src-fontify-natively t)
  (require 'htmlize)
#+END_SRC
1 - Turns off some annoying "are you sure?" prompts on tangle export \\
2 - Makes tabs work in the source code blocks the same as it would in a buffer with that source code \\
3 - Makes it so underscores aren't interpreted as subscripts unless used with braces \\
(I often need underscores for file/variable names) \\
4 - Make source code colored based on the language \\
5 - ~htmlize~ will colorize code in the HTML export of orgmode
For more info on any of these variables, again, use ~C-h v [variable] RET~

* C++ 
Here we'll setup a development environment as feature rich as an IDE \\
I based it on [[http://syamajala.github.io/c-ide.html][this guide]] - but I've really pared it down. I still seem to get all the same autocomplete/navigation and error squigglies, so I don't really know what I'm missing here \\
** RTags
The backbone of most modern C++ dev environments leverage ~libclang~ to parse the C++ codebase. In Emacs we do the same using a independent system called ~rtags~ which runs as a deamon parsing your codebase in the background. Emacs has a ~rtags~ package for launching and communicating with the deamon which will then feed up all the information available to the compiler front-end. So to get started you need to go to the [[https://github.com/Andersbakken/rtags][rtags github]] and install rtags. The rtags documentation is extensive, but for our purposes we just need to have rtags in the path. The rest will be handles by Emacs. Once you're done installing, if you want to sanity check you can run ~rdm~ from the command line and see some process boot up (you can kill it - Emacs will be launching ~rdm~ itself by the end of this configuration)

Once you have it installed somewhere in your path we need to do the following: \\
1 - enable rtags \\
2 - enable standard key binding \\
2 - enable diagnostics (needed for code completion!) \\
3 - enable code completion \\
4 - launch the rtags deamon
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'rtags)
  (rtags-enable-standard-keybindings)
  (setq rtags-autostart-diagnostics t)
  (rtags-diagnostics)
  (setq rtags-completions-enabled t)
  (rtags-start-process-unless-running)
#+END_SRC
#+BEGIN_QUOTE
There are c++ code base parsers like ~ctags~ ~ggtags~ etc. which are much easier to set up but they  will not ultimately give you the same level of robustness and information b/c only ~rtags~ leverages a compiler front
#+END_QUOTE
#+BEGIN_QUOTE
Even if you're not building with ~clang~ (say you're targetting embedded), ~rtags~ should be able to index your project
#+END_QUOTE
** Company
Next we turn on ~company~. The package that will do autocompletion for us (it standards for COMPlete ANYthing)
#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'company)
  (push 'company-rtags company-backends)
  (global-company-mode)
  (define-key c-mode-base-map (kbd "<C-tab>") (function company-complete))
#+END_SRC
looking at the documentation we see that ~push~ will take the 1st argument and add it to the beginning of the list provided in the 2nd argument. ~company-backends~ is "a list of active backends (completion engines)". ~company-rtags~ is a backend provided by the ~rtags~ guys. See the documentation for more info :)
** CMake-IDE
The last part is adding ~cmake-ide~
#+BEGIN_SRC emacs-lisp :tangle init.el
  (cmake-ide-setup)
#+END_SRC
This is the glue that will point ~rtags~  to the right location and make everything work. When you are in a buffer for a c++ file it will look for it's corresponding CMakeLists.txt and run cmake and hook ~rtags~ up.
** Using the environment
Now that everything is set up there are a couple of small caveats before you can use it all: \\
1 - You need to give ~cmake-ide~ a build directory by setting ~cmake-ide-build-dir~
#+BEGIN_SRC emacs-lisp
  (setq cmake-ide-build-dir '"/some/build/directory/")
#+END_SRC
2 - You need to run cmake [[https://github.com/atilaneves/cmake-ide/issues/75#issuecomment-268973147][at least once]] manually in that directory with all the flags you want
#+BEGIN_EXAMPLE 
 cd /path/to/build/directory
 cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -D[your flags/options.. like build release/debug] /path/to/source/directory
#+END_EXAMPLE
The first flag makes ~cmake~ export a ~.json~ file describing the build. ~rtags~ uses this file to understand which source files to feed into ~libclang~ (so this is happening independent of your actual build toochain whether it be ~gcc~ or something else)

These last two steps are a bit clunky but only have to be done once. After that rtags will run in the background reindexing the project when appropriate. You can now jump to definitions with ~C-c r .~, things will autcomplete with ~C-TAB~, errors will get underlined (when your cursor rests over the error it'll print in the minibuffer), and things will compile when you run ~M-x cmake-ide-compile~. ~rtags~ in particular has a ton of different features - so look at their github for more info

#+BEGIN_QUOTE
Note that things sometimes get a little wonky when rtags is not done indexing in the background. So sometimes you just need to give it a little time to reindex! This is especially true after the first time you build the project. So give it a minute to settle down before you frantically try to debug things
#+END_QUOTE
#+BEGIN_QUOTE
*Wishlist/TODOs*
- Make the last clunky part into an elisp function that prompts for a build directory
- Find a way to inspect the Rtags backend's state so that you can have something in the mode-line that tells you if it's still busy
#+END_QUOTE
#+BEGIN_QUOTE
This webpage is generated from an org-document (at ~./index.org~) that also generates all the files described. 

Once opened in Emacs:\\
- ~C-c C-e h h~ generates the webpage  \\
- ~C-c C-v C-t~ exports the code blocks into the appropriate files\\
#+END_QUOTE
